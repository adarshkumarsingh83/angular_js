Why this is better than current examples?

Concern 1: The unit is isolated in its concerns: That is, the view state required to render the view (the thumbnail items list) is computed by the unit itself. I don't need any magical knowledge about the inner workings. I don't have the boilerplate of creating or linking the state into my main application. Furthermore these views can be created every time an editor is required. This means that for multiple instances of the frame editor, each has its own view state. When this state is created, the global app state is not mutated to accommodate it.


Concern 2: There is a legitimate interface to the unit. So not only do we not need special knowledge of the inner workings, the things I am interested in interacting with exist as well defined inspectable tokens on the unit. This is far better than the current event injection techniques which a) require me to insert the events every time I render (a completely hideous uninituitive notion) and b) know which events the unit supports. The interface here acts as usable documentation, or pointers into my documentation. Further, if I need to communicate with the unit, I don't do so through an arbitrary bag of state. I can expose inputs on the unit for this purpose. This allows me to assert consistent internal state as well as providing some help to the user about the intended use.

Concern 3: Immutable and referentiall transparent. Note that this doesn't rely on mutation or impure render functions. There is no mutable state in the tree or anywhere else. The view state, just like the application state is an immutable observable defined in some function scope, we use the snapshot from this view state to render the view. The view state is not hidden, you can inspect, test and change the state, but you really don't need to.

Concern 4: Leaking internals. So for a good modular approach, I am going to write these views in isolation, test them in isolation and publish them in isolation. Internally I am going to listen to events on the portion of the DOM that I own, I am going to trigger the observables in my state, and the unit is going to be an interactive standalone unit that actually does something. Just like the top level state, this requires consistency, which at the top level we manage by having deep knowledge and understanding of this state that we own. Providing this state as a thing that should intentionally be updated is dangerous, because the user does not and shouldn't need deep knowledge of the nuances of our internal state. We should not be using the view state as a communication mechanism. This would be like getting a subprocess to do something by mutating its memory instead of sending it a message through stdin.

Furthermore, the events that I create for intenal use have no place on the global state (this would be terrible for readability if we mixed the public and private events together). By keeping the internal events internal (though they are readable if you must inspect) and by exposing events I can only listen to (not emit) on the public interface, my reasoning power about event origin increases. There is no temptation for the user to have my view emit somethign to affect state downstream, but you can find the unit and do this for debugging still.
